use std::path::PathBuf;

use clap::{Parser, Subcommand, ValueEnum};
use memo_workflow_cli::{
    ADD_TOKEN_PREFIX, AppError, ListResult, RuntimeConfig, build_script_filter, execute_add,
    execute_db_init, execute_list,
};
use serde::Serialize;

#[derive(Debug, Parser)]
#[command(author, version, about = "Memo workflow adapter CLI")]
struct Cli {
    #[command(subcommand)]
    command: Command,
}

#[derive(Debug, Subcommand)]
enum Command {
    /// Build Alfred script-filter JSON for memo workflow.
    ScriptFilter {
        /// Query text from Alfred.
        #[arg(long, default_value = "")]
        query: String,
    },
    /// Add one memo item.
    Add {
        /// Memo text to append.
        #[arg(long)]
        text: String,
        /// Override sqlite DB path for this call.
        #[arg(long)]
        db: Option<PathBuf>,
        /// Override source label for this call.
        #[arg(long)]
        source: Option<String>,
        /// Output format.
        #[arg(long, value_enum, default_value_t = ResultMode::Text)]
        mode: ResultMode,
    },
    /// Initialize memo sqlite schema.
    DbInit {
        /// Override sqlite DB path for this call.
        #[arg(long)]
        db: Option<PathBuf>,
        /// Output format.
        #[arg(long, value_enum, default_value_t = ResultMode::Text)]
        mode: ResultMode,
    },
    /// List memo records in newest-first order.
    List {
        /// Max rows to return.
        #[arg(long, default_value_t = 8)]
        limit: usize,
        /// Row offset for paging.
        #[arg(long, default_value_t = 0)]
        offset: usize,
        /// Override sqlite DB path for this call.
        #[arg(long)]
        db: Option<PathBuf>,
        /// Output format.
        #[arg(long, value_enum, default_value_t = ResultMode::Text)]
        mode: ResultMode,
    },
    /// Execute one Alfred action token.
    Action {
        /// Action token generated by script-filter.
        #[arg(long)]
        token: String,
        /// Output format.
        #[arg(long, value_enum, default_value_t = ResultMode::Text)]
        mode: ResultMode,
        /// Override sqlite DB path for this call.
        #[arg(long)]
        db: Option<PathBuf>,
        /// Override source label for this call.
        #[arg(long)]
        source: Option<String>,
    },
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]
#[value(rename_all = "kebab-case")]
enum ResultMode {
    Text,
    Json,
}

#[derive(Debug, Serialize)]
struct JsonEnvelope<T> {
    ok: bool,
    result: Option<T>,
    error: Option<String>,
}

fn main() {
    let cli = Cli::parse();

    if let Err(error) = run(cli) {
        eprintln!("{}", error.message());
        std::process::exit(error.exit_code());
    }
}

fn run(cli: Cli) -> Result<(), AppError> {
    let config = RuntimeConfig::from_env()?;

    match cli.command {
        Command::ScriptFilter { query } => {
            let feedback = build_script_filter(&query, &config)?;
            let json = feedback.to_json().map_err(|error| {
                AppError::Runtime(format!("failed to serialize feedback: {error}"))
            })?;
            println!("{json}");
        }
        Command::Add {
            text,
            db,
            source,
            mode,
        } => {
            let result = execute_add(&text, source.as_deref(), db, &config)?;
            emit(mode, result, |res| {
                format!("added {} at {}", res.item_id, res.created_at)
            })?;
        }
        Command::DbInit { db, mode } => {
            let result = execute_db_init(db, &config)?;
            emit(mode, result, |res| format!("initialized {}", res.db_path))?;
        }
        Command::List {
            limit,
            offset,
            db,
            mode,
        } => {
            let result = execute_list(db, limit, offset, &config)?;
            emit(mode, result, render_list_text)?;
        }
        Command::Action {
            token,
            mode,
            db,
            source,
        } => {
            if token == memo_workflow_cli::DB_INIT_TOKEN {
                let result = execute_db_init(db, &config)?;
                emit(mode, result, |res| format!("initialized {}", res.db_path))?;
                return Ok(());
            }

            let text = if let Some(raw) = token.strip_prefix(ADD_TOKEN_PREFIX) {
                raw
            } else {
                token.as_str()
            };

            let result = execute_add(text, source.as_deref(), db, &config)?;
            emit(mode, result, |res| {
                format!("added {} at {}", res.item_id, res.created_at)
            })?;
        }
    }

    Ok(())
}

fn render_list_text(rows: &Vec<ListResult>) -> String {
    if rows.is_empty() {
        return "no memo records".to_string();
    }

    let mut lines = Vec::with_capacity(rows.len());
    for row in rows {
        lines.push(format!(
            "{} {} [{}] {}",
            row.item_id, row.created_at, row.state, row.text_preview
        ));
    }

    lines.join("\n")
}

fn emit<T, F>(mode: ResultMode, result: T, text_renderer: F) -> Result<(), AppError>
where
    T: Serialize,
    F: Fn(&T) -> String,
{
    match mode {
        ResultMode::Text => println!("{}", text_renderer(&result)),
        ResultMode::Json => {
            let payload = JsonEnvelope {
                ok: true,
                result: Some(result),
                error: None,
            };
            let json = serde_json::to_string(&payload)
                .map_err(|error| AppError::Runtime(format!("failed to serialize json: {error}")))?;
            println!("{json}");
        }
    }

    Ok(())
}
