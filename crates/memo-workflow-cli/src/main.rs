use std::path::PathBuf;

use clap::{Parser, Subcommand, ValueEnum};
use memo_workflow_cli::{
    ADD_TOKEN_PREFIX, AppError, COPY_JSON_TOKEN_PREFIX, COPY_TOKEN_PREFIX, DELETE_TOKEN_PREFIX,
    ListResult, RuntimeConfig, SearchMatchMode, SearchResult, UPDATE_TOKEN_PREFIX,
    build_script_filter, execute_add, execute_db_init, execute_delete, execute_fetch_item,
    execute_list, execute_search, execute_update, parse_add_token, parse_copy_json_token,
    parse_copy_token, parse_delete_token, parse_update_token,
};
use serde::Serialize;

#[derive(Debug, Parser)]
#[command(author, version, about = "Memo workflow adapter CLI")]
struct Cli {
    #[command(subcommand)]
    command: Command,
}

#[derive(Debug, Subcommand)]
enum Command {
    /// Build Alfred script-filter JSON for memo workflow.
    ScriptFilter {
        /// Query text from Alfred.
        #[arg(long, default_value = "")]
        query: String,
    },
    /// Add one memo item.
    Add {
        /// Memo text to append.
        #[arg(long)]
        text: String,
        /// Override sqlite DB path for this call.
        #[arg(long)]
        db: Option<PathBuf>,
        /// Override source label for this call.
        #[arg(long)]
        source: Option<String>,
        /// Output format.
        #[arg(long, value_enum, default_value_t = ResultMode::Text)]
        mode: ResultMode,
    },
    /// Update one memo item.
    Update {
        /// Memo item identifier (itm_XXXXXXXX or integer id).
        #[arg(long)]
        item_id: String,
        /// Updated memo text.
        #[arg(long)]
        text: String,
        /// Override sqlite DB path for this call.
        #[arg(long)]
        db: Option<PathBuf>,
        /// Output format.
        #[arg(long, value_enum, default_value_t = ResultMode::Text)]
        mode: ResultMode,
    },
    /// Hard-delete one memo item.
    Delete {
        /// Memo item identifier (itm_XXXXXXXX or integer id).
        #[arg(long)]
        item_id: String,
        /// Override sqlite DB path for this call.
        #[arg(long)]
        db: Option<PathBuf>,
        /// Output format.
        #[arg(long, value_enum, default_value_t = ResultMode::Text)]
        mode: ResultMode,
    },
    /// Initialize memo sqlite schema.
    DbInit {
        /// Override sqlite DB path for this call.
        #[arg(long)]
        db: Option<PathBuf>,
        /// Output format.
        #[arg(long, value_enum, default_value_t = ResultMode::Text)]
        mode: ResultMode,
    },
    /// List memo records in newest-first order.
    List {
        /// Max rows to return.
        #[arg(long, default_value_t = 8)]
        limit: usize,
        /// Row offset for paging.
        #[arg(long, default_value_t = 0)]
        offset: usize,
        /// Override sqlite DB path for this call.
        #[arg(long)]
        db: Option<PathBuf>,
        /// Output format.
        #[arg(long, value_enum, default_value_t = ResultMode::Text)]
        mode: ResultMode,
    },
    /// Search memo records by query text.
    Search {
        /// Search query text.
        #[arg(long)]
        query: String,
        /// Search match mode.
        #[arg(long = "match", value_enum, default_value_t = SearchMatch::Fts)]
        match_mode: SearchMatch,
        /// Max rows to return.
        #[arg(long, default_value_t = 20)]
        limit: usize,
        /// Row offset for paging.
        #[arg(long, default_value_t = 0)]
        offset: usize,
        /// Override sqlite DB path for this call.
        #[arg(long)]
        db: Option<PathBuf>,
        /// Output format.
        #[arg(long, value_enum, default_value_t = ResultMode::Text)]
        mode: ResultMode,
    },
    /// Execute one Alfred action token.
    Action {
        /// Action token generated by script-filter.
        #[arg(long)]
        token: String,
        /// Output format.
        #[arg(long, value_enum, default_value_t = ResultMode::Text)]
        mode: ResultMode,
        /// Override sqlite DB path for this call.
        #[arg(long)]
        db: Option<PathBuf>,
        /// Override source label for this call.
        #[arg(long)]
        source: Option<String>,
    },
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]
#[value(rename_all = "kebab-case")]
enum ResultMode {
    Text,
    Json,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]
#[value(rename_all = "kebab-case")]
enum SearchMatch {
    Fts,
    Prefix,
    Contains,
}

impl From<SearchMatch> for SearchMatchMode {
    fn from(value: SearchMatch) -> Self {
        match value {
            SearchMatch::Fts => SearchMatchMode::Fts,
            SearchMatch::Prefix => SearchMatchMode::Prefix,
            SearchMatch::Contains => SearchMatchMode::Contains,
        }
    }
}

#[derive(Debug, Serialize)]
struct JsonEnvelope<T> {
    ok: bool,
    result: Option<T>,
    error: Option<String>,
}

fn main() {
    let cli = Cli::parse();

    if let Err(error) = run(cli) {
        eprintln!("{}", error.message());
        std::process::exit(error.exit_code());
    }
}

fn run(cli: Cli) -> Result<(), AppError> {
    let config = RuntimeConfig::from_env()?;

    match cli.command {
        Command::ScriptFilter { query } => {
            let feedback = build_script_filter(&query, &config)?;
            let json = feedback.to_json().map_err(|error| {
                AppError::Runtime(format!("failed to serialize feedback: {error}"))
            })?;
            println!("{json}");
        }
        Command::Add {
            text,
            db,
            source,
            mode,
        } => {
            let result = execute_add(&text, source.as_deref(), db, &config)?;
            emit(mode, result, |res| {
                format!("added {} at {}", res.item_id, res.created_at)
            })?;
        }
        Command::Update {
            item_id,
            text,
            db,
            mode,
        } => {
            let result = execute_update(&item_id, &text, db, &config)?;
            emit(mode, result, |res| {
                format!(
                    "updated {} at {} (state={}, cleared_derivations={}, cleared_workflows={})",
                    res.item_id,
                    res.updated_at,
                    res.state,
                    res.cleared_derivations,
                    res.cleared_workflow_anchors
                )
            })?;
        }
        Command::Delete { item_id, db, mode } => {
            let result = execute_delete(&item_id, db, &config)?;
            emit(mode, result, |res| {
                format!(
                    "deleted {} at {} (removed_derivations={}, removed_workflows={})",
                    res.item_id,
                    res.deleted_at,
                    res.removed_derivations,
                    res.removed_workflow_anchors
                )
            })?;
        }
        Command::DbInit { db, mode } => {
            let result = execute_db_init(db, &config)?;
            emit(mode, result, |res| format!("initialized {}", res.db_path))?;
        }
        Command::List {
            limit,
            offset,
            db,
            mode,
        } => {
            let result = execute_list(db, limit, offset, &config)?;
            emit(mode, result, render_list_text)?;
        }
        Command::Search {
            query,
            match_mode,
            limit,
            offset,
            db,
            mode,
        } => {
            let result = execute_search(db, &query, match_mode.into(), limit, offset, &config)?;
            emit(mode, result, render_search_text)?;
        }
        Command::Action {
            token,
            mode,
            db,
            source,
        } => {
            if token == memo_workflow_cli::DB_INIT_TOKEN {
                let result = execute_db_init(db, &config)?;
                emit(mode, result, |res| format!("initialized {}", res.db_path))?;
                return Ok(());
            }

            if token.starts_with(COPY_JSON_TOKEN_PREFIX) {
                let item_id = parse_copy_json_token(&token)
                    .ok_or_else(|| AppError::User("invalid copy-json action token".to_string()))?;
                let result = execute_fetch_item(&item_id, db, &config)?;
                emit(mode, result, render_item_json_text)?;
                return Ok(());
            }

            if token.starts_with(COPY_TOKEN_PREFIX) {
                let item_id = parse_copy_token(&token)
                    .ok_or_else(|| AppError::User("invalid copy action token".to_string()))?;
                let result = execute_fetch_item(&item_id, db, &config)?;
                emit(mode, result, |res| res.text.clone())?;
                return Ok(());
            }

            if token.starts_with(UPDATE_TOKEN_PREFIX) {
                let (item_id, text) = parse_update_token(&token)
                    .ok_or_else(|| AppError::User("invalid update action token".to_string()))?;
                let result = execute_update(&item_id, &text, db, &config)?;
                emit(mode, result, |res| {
                    format!(
                        "updated {} at {} (state={}, cleared_derivations={}, cleared_workflows={})",
                        res.item_id,
                        res.updated_at,
                        res.state,
                        res.cleared_derivations,
                        res.cleared_workflow_anchors
                    )
                })?;
                return Ok(());
            }

            if token.starts_with(DELETE_TOKEN_PREFIX) {
                let item_id = parse_delete_token(&token)
                    .ok_or_else(|| AppError::User("invalid delete action token".to_string()))?;
                let result = execute_delete(&item_id, db, &config)?;
                emit(mode, result, |res| {
                    format!(
                        "deleted {} at {} (removed_derivations={}, removed_workflows={})",
                        res.item_id,
                        res.deleted_at,
                        res.removed_derivations,
                        res.removed_workflow_anchors
                    )
                })?;
                return Ok(());
            }

            let text = if token.starts_with(ADD_TOKEN_PREFIX) {
                parse_add_token(&token).unwrap_or_default()
            } else {
                token
            };

            let result = execute_add(&text, source.as_deref(), db, &config)?;
            emit(mode, result, |res| {
                format!("added {} at {}", res.item_id, res.created_at)
            })?;
        }
    }

    Ok(())
}

fn render_list_text(rows: &Vec<ListResult>) -> String {
    if rows.is_empty() {
        return "no memo records".to_string();
    }

    let mut lines = Vec::with_capacity(rows.len());
    for row in rows {
        lines.push(format!(
            "{} {} [{}] {}",
            row.item_id, row.created_at, row.state, row.text_preview
        ));
    }

    lines.join("\n")
}

fn render_search_text(rows: &Vec<SearchResult>) -> String {
    if rows.is_empty() {
        return "no search matches".to_string();
    }

    let mut lines = Vec::with_capacity(rows.len());
    for row in rows {
        lines.push(format!(
            "{} {} [score={:.3}] {}",
            row.item_id, row.created_at, row.score, row.text_preview
        ));
    }

    lines.join("\n")
}

fn render_item_json_text<T>(value: &T) -> String
where
    T: Serialize,
{
    serde_json::to_string(value).unwrap_or_else(|_| "{}".to_string())
}

fn emit<T, F>(mode: ResultMode, result: T, text_renderer: F) -> Result<(), AppError>
where
    T: Serialize,
    F: Fn(&T) -> String,
{
    match mode {
        ResultMode::Text => println!("{}", text_renderer(&result)),
        ResultMode::Json => {
            let payload = JsonEnvelope {
                ok: true,
                result: Some(result),
                error: None,
            };
            let json = serde_json::to_string(&payload)
                .map_err(|error| AppError::Runtime(format!("failed to serialize json: {error}")))?;
            println!("{json}");
        }
    }

    Ok(())
}
