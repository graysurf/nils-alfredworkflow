# Alfred Workflow Monorepo Design (Rust Core + Bash Glue)

## 1. Goals

- Build and maintain multiple Alfred workflows in one repository.
- Centralize shared logic in Rust libraries and reusable shell tooling.
- Keep each workflow independently packageable as `.alfredworkflow`.
- Enable deterministic local build, CI validation, and release packaging.
- Preserve fast iteration for Alfred-specific glue scripts.

## 2. Non-Goals

- Replacing Alfred runtime behavior.
- Building a custom workflow engine.
- Requiring Alfred GUI for every build step.

## 3. Architecture Principles

- Single source of truth for workflow metadata: each workflow has a manifest.
- Shared code first: common behavior lives in `crates/` (Rust) and `scripts/lib/` (Bash).
- Thin workflow adapters: workflow-specific Bash only for Alfred I/O boundaries.
- Reproducible packaging: every artifact is generated by scripts/commands, never manual zip.
- Validation gates before packaging and release.

## 4. Proposed Repository Layout

```text
.
|-- Cargo.toml
|-- Cargo.lock
|-- rust-toolchain.toml
|-- README.md
|-- docs/
|   |-- ALFRED_WORKFLOW_MONOREPO_DESIGN.md
|   |-- ARCHITECTURE.md
|   |-- RELEASE.md
|   `-- WORKFLOW_GUIDE.md
|-- crates/
|   |-- alfred-core/                 # Shared Alfred models: items, variables, feedback JSON
|   |-- alfred-plist/                # info.plist template/render/validation helpers
|   |-- workflow-common/             # Domain logic reused by multiple workflows
|   |-- workflow-cli/                # Generic CLI entry used by Bash glue
|   `-- xtask/                       # Build/package/install/release task runner
|-- workflows/
|   |-- open-project/
|   |   |-- workflow.toml            # Workflow manifest (bundle id, version, assets, entrypoints)
|   |   |-- src/
|   |   |   |-- info.plist.template  # Template rendered during packaging
|   |   |   `-- assets/
|   |   |       `-- icon.png
|   |   |-- scripts/
|   |   |   |-- script_filter.sh     # Alfred script filter glue
|   |   |   `-- action_open.sh       # Alfred action glue
|   |   `-- tests/
|   |       `-- smoke.sh
|   |-- github-open/
|   |   |-- workflow.toml
|   |   |-- src/
|   |   |-- scripts/
|   |   `-- tests/
|   `-- _template/
|       |-- workflow.toml
|       |-- src/info.plist.template
|       `-- scripts/
|-- scripts/
|   |-- lib/
|   |   |-- common.sh                # Logging, argument parsing, env loading
|   |   `-- alfred.sh                # Alfred JSON output helpers
|   |-- workflow-pack.sh             # Wrapper to package one/all workflows
|   |-- workflow-install.sh          # Install built workflow via `open`
|   |-- workflow-lint.sh             # shellcheck, shfmt, plist lint, manifest lint
|   |-- workflow-test.sh             # Rust + shell + smoke tests
|   `-- workflow-new.sh              # Scaffold from workflows/_template
|-- dist/                            # Built artifacts (.alfredworkflow, checksums)
|-- build/                           # Staging dir (ephemeral)
|-- .github/
|   `-- workflows/
|       |-- ci.yml
|       `-- release.yml
`-- .editorconfig
```

## 5. Workflow Manifest (`workflow.toml`)

Each workflow should define:

- `id`: short unique id (`open-project`)
- `name`: display name
- `bundle_id`: Alfred bundle id
- `version`: workflow version
- `entry`: script filter/action script names
- `rust_binary`: optional binary name to include
- `assets`: files copied into package root
- `env`: default variable values exported in `info.plist`
- `alfred`: minimum Alfred/macOS compatibility metadata

This keeps packaging logic generic and removes hardcoded paths.

## 6. Build and Packaging Flow

### 6.1 Build one workflow

1. Validate manifest and required files.
2. Build Rust binaries (`cargo build --release -p <crate>`).
3. Render `info.plist` from template + manifest values.
4. Copy scripts/assets/binaries into staging dir (`build/workflows/<id>/pkg`).
5. Run `plutil -lint info.plist`.
6. Zip staging dir into `dist/<id>/<version>/<name>.alfredworkflow`.
7. Generate checksum file (`sha256`).

### 6.2 Build all workflows

- Iterate over `workflows/*/workflow.toml` and execute the same pipeline.
- Fail fast if any workflow fails validation.

## 7. Install and Dev Loop

- `scripts/workflow-install.sh <id>`:
  - Locate latest built artifact in `dist/<id>/`.
  - Run `open <artifact>.alfredworkflow`.
- Optional dev command:
  - `scripts/workflow-pack.sh <id> --install`
  - Packs and immediately opens artifact for quick feedback loop.

## 8. Rust/Bash Responsibility Split

### Rust (core, testable, reusable)

- Filesystem scanning, parsing, sorting, and filtering logic.
- Data modeling and JSON generation for Alfred feedback items.
- Caching/indexing logic for performance-sensitive workflows.
- Shared domain rules across workflows.

### Bash (integration glue)

- Alfred argument/environment boundary handling.
- Small orchestration wrappers around Rust binaries.
- Side effects: opening apps, invoking system commands, writing usage files.

Rule: keep Bash scripts thin and deterministic; push heavy logic to Rust.

## 9. Validation and Testing Strategy

- Rust:
  - `cargo fmt --check`
  - `cargo clippy --workspace --all-targets -- -D warnings`
  - `cargo test --workspace`
- Shell:
  - `shellcheck` for all `*.sh`
  - `shfmt -d`
- Packaging smoke tests (per workflow):
  - Build artifact
  - Unzip and assert required files exist (`info.plist`, scripts, icon)
  - Validate plist syntax with `plutil -lint`
  - Optional JSON contract checks for script filter output

## 10. CI/CD Baseline

- Pull Request CI (`ci.yml`):
  - Lint Rust and shell.
  - Run tests.
  - Run packaging smoke test for changed workflows.
- Release (`release.yml`):
  - Triggered by tag.
  - Build selected workflows.
  - Upload `.alfredworkflow` artifacts and checksums to GitHub Releases.

## 11. Versioning and Release Model

- Keep workflow version in each `workflow.toml`.
- Option A: independent version per workflow (recommended for many workflows).
- Option B: single monorepo version (simpler but less flexible).
- Release notes generated from commits scoped to workflow id.

## 12. Additional Recommended Additions

- `workflows/_template` scaffold to bootstrap new workflows quickly.
- `docs/DECISIONS/` (ADR) for major architecture choices.
- Local benchmark command for script filter latency comparisons.
- Optional cache layer contract (`$HOME/.cache/<repo>/<workflow>.json`) with schema versioning.
- Compatibility matrix (Alfred version, macOS version, CPU arch).
- `scripts/workflow-clean.sh` to clear `build/` and stale dist outputs.

## 13. Suggested Initial Command Surface

- `cargo run -p xtask -- workflow list`
- `cargo run -p xtask -- workflow lint [--id <workflow>]`
- `cargo run -p xtask -- workflow test [--id <workflow>]`
- `cargo run -p xtask -- workflow pack --id <workflow> [--install]`
- `cargo run -p xtask -- workflow pack --all`
- `cargo run -p xtask -- workflow new --id <workflow>`

If `xtask` is considered too heavy initially, mirror these with shell wrappers under `scripts/`.

## 14. Migration Plan from Current Single-Workflow Repo

1. Move current extracted files to `workflows/open-project/src/`.
2. Create `workflows/open-project/workflow.toml`.
3. Move current inline scripts out of plist into `workflows/open-project/scripts/`.
4. Add minimal Rust crate for current filtering logic.
5. Add packaging script that regenerates `.alfredworkflow`.
6. Add CI smoke test for generated artifact.
7. Add second workflow to validate multi-workflow architecture early.
